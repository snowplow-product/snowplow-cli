/*
Copyright (c) 2013-present Snowplow Analytics Ltd.
All rights reserved.
This software is made available by Snowplow Analytics, Ltd.,
under the terms of the Snowplow Limited Use License Agreement, Version 1.0
located at https://docs.snowplow.io/limited-use-license-1.0
BY INSTALLING, DOWNLOADING, ACCESSING, USING OR DISTRIBUTING ANY PORTION
OF THE SOFTWARE, YOU AGREE TO THE TERMS OF SUCH LICENSE AGREEMENT.
*/

package cmd

import (
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/cobra/doc"
)

var docsCommand = &cobra.Command{
	Use:    "generate-docs [output-dir]",
	Short:  "Generate markdown documentation for snowplow-cli",
	Hidden: true,
	Args:   cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		outputDir := args[0]

		// Clean the output directory if it exists
		if _, err := os.Stat(outputDir); !os.IsNotExist(err) {
			if err := os.RemoveAll(outputDir); err != nil {
				slog.Error("Failed to clean output directory", "error", err)
				os.Exit(1)
			}
		}

		// Create fresh output directory
		if err := os.MkdirAll(outputDir, 0755); err != nil {
			slog.Error("Failed to create output directory", "error", err)
			os.Exit(1)
		}

		// Generate markdown docs
		if err := doc.GenMarkdownTree(RootCmd, outputDir); err != nil {
			slog.Error("Failed to generate markdown documentation", "error", err)
			os.Exit(1)
		}

		position := 0
		err := filepath.Walk(outputDir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}
			// Convert markdown files to Docusaurus format
			// skip the autocompletion docs
			// skip the root command - nothing useful, probably have to be done by hand
			if !info.IsDir() && strings.HasSuffix(info.Name(), ".md") && !strings.Contains(info.Name(), "completion") && info.Name() != "snowplow-cli.md" {
				if err := convertToDocusaurus(path, position); err != nil {
					return err
				}
				baseName := strings.TrimSuffix(info.Name(), ".md")
				// Create new directory
				dirPath := filepath.Join(outputDir, baseName)
				if err := os.MkdirAll(dirPath, 0755); err != nil {
					return err
				}
				// Move file
				err = os.Rename(path, filepath.Join(dirPath, "index.md"))
				if err != nil {
					return err
				}

				position++
			}
			// Remove autocompletion docs
			// Remove snowplow-cli.md
			if !info.IsDir() && (strings.Contains(info.Name(), "completion") || info.Name() == "snowplow-cli.md") {
				os.Remove(path)
			}

			return nil
		})

		if err != nil {
			slog.Error("Failed to convert documentation to Docusaurus format", "error", err)
			os.Exit(1)
		}

		slog.Info("Documentation generated successfully", "path", filepath.Clean(outputDir))
	},
}

func convertToDocusaurus(filepath string, position int) error {
	// Read the file
	content, err := os.ReadFile(filepath)
	if err != nil {
		return err
	}

	lines := strings.Split(string(content), "\n")

	// Extract title from the first heading
	title := ""
	for _, line := range lines {
		if strings.HasPrefix(line, "## ") {
			title = strings.TrimPrefix(line, "## ")
			break
		}
	}

	// Create new content with front matter
	var newContent strings.Builder

	// Add front matter
	newContent.WriteString("---\n")
	newContent.WriteString(fmt.Sprintf("title: %s\n", title))
	newContent.WriteString(fmt.Sprintf("date: %s\n", time.Now().Format("2006-01-02")))
	sidebarLabel := strings.TrimPrefix(title, "snowplow-cli ")
	newContent.WriteString(fmt.Sprintf("sidebar_label: %s\n", sidebarLabel))
	newContent.WriteString(fmt.Sprintf("sidebar_position: %d\n", position))
	newContent.WriteString("---\n\n")

	// Process content
	inCodeBlock := false
	for _, line := range lines {
		if strings.HasPrefix(line, "## "+title) {
			continue
		}

		// Handle code blocks
		if strings.HasPrefix(line, "```") {
			inCodeBlock = !inCodeBlock
			if strings.HasPrefix(line, "```markdown") {
				// Skip markdown code block markers
				continue
			}
		}

		processedLine := replaceMarkdownLinks(line)
		// Add line to new content with escaped angle brackets
		escapedLine := strings.ReplaceAll(strings.ReplaceAll(processedLine, "<", "\\<"), ">", "\\>")
		// Remove link to the autocomplete command
		if !strings.Contains(escapedLine, "[snowplow-cli completion]") {
			newContent.WriteString(escapedLine + "\n")
		}
	}

	// Remove the auto-generated notice
	final := strings.Replace(newContent.String(),
		"###### Auto generated by spf13/cobra on "+time.Now().Format("2-Jan-2006")+"\n",
		"", -1)

	return os.WriteFile(filepath, []byte(final), 0644)
}

// Convert links from name.md to ../name
func replaceMarkdownLinks(line string) string {
	return strings.ReplaceAll(strings.ReplaceAll(line, "](", "](../"), ".md)", ")")
}

func init() {
	RootCmd.AddCommand(docsCommand)
}
